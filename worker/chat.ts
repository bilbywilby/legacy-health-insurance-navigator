import OpenAI from 'openai';
import type { Message, ToolCall, InsuranceDocument } from './types';
import { getToolDefinitions, executeTool } from './tools';
import { ChatCompletionMessageFunctionToolCall } from 'openai/resources/index.mjs';
export class ChatHandler {
  private client: OpenAI;
  private model: string;
  constructor(aiGatewayUrl: string, apiKey: string, model: string) {
    this.client = new OpenAI({
      baseURL: aiGatewayUrl,
      apiKey: apiKey
    });
    this.model = model;
  }
  async processMessage(
    message: string,
    conversationHistory: Message[],
    documents: InsuranceDocument[] = [],
    onChunk?: (chunk: string) => void
  ): Promise<{
    content: string;
    toolCalls?: ToolCall[];
  }> {
    const messages = this.buildConversationMessages(message, conversationHistory, documents);
    const toolDefinitions = await getToolDefinitions();
    if (onChunk) {
      const stream = await this.client.chat.completions.create({
        model: this.model,
        messages,
        tools: toolDefinitions,
        tool_choice: 'auto',
        max_completion_tokens: 16000,
        stream: true,
      });
      return this.handleStreamResponse(stream, message, conversationHistory, documents, onChunk);
    }
    const completion = await this.client.chat.completions.create({
      model: this.model,
      messages,
      tools: toolDefinitions,
      tool_choice: 'auto',
      max_tokens: 16000,
      stream: false
    });
    return this.handleNonStreamResponse(completion, message, conversationHistory, documents);
  }
  private async handleStreamResponse(
    stream: AsyncIterable<OpenAI.Chat.Completions.ChatCompletionChunk>,
    message: string,
    conversationHistory: Message[],
    documents: InsuranceDocument[],
    onChunk: (chunk: string) => void
  ) {
    let fullContent = '';
    const accumulatedToolCalls: ChatCompletionMessageFunctionToolCall[] = [];
    try {
      for await (const chunk of stream) {
        const delta = chunk.choices[0]?.delta;
        if (delta?.content) {
          fullContent += delta.content;
          onChunk(delta.content);
        }
        if (delta?.tool_calls) {
          for (let i = 0; i < delta.tool_calls.length; i++) {
            const deltaToolCall = delta.tool_calls[i];
            if (!accumulatedToolCalls[i]) {
              accumulatedToolCalls[i] = {
                id: deltaToolCall.id || `tool_${Date.now()}_${i}`,
                type: 'function',
                function: {
                  name: deltaToolCall.function?.name || '',
                  arguments: deltaToolCall.function?.arguments || ''
                }
              };
            } else {
              if (deltaToolCall.function?.name && !accumulatedToolCalls[i].function.name) {
                accumulatedToolCalls[i].function.name = deltaToolCall.function.name;
              }
              if (deltaToolCall.function?.arguments) {
                accumulatedToolCalls[i].function.arguments += deltaToolCall.function.arguments;
              }
            }
          }
        }
      }
    } catch (error) {
      console.error('Stream processing error:', error);
      throw new Error('Stream processing failed');
    }
    if (accumulatedToolCalls.length > 0) {
      const executedTools = await this.executeToolCalls(accumulatedToolCalls);
      const finalResponse = await this.generateToolResponse(message, conversationHistory, documents, accumulatedToolCalls, executedTools);
      return { content: finalResponse, toolCalls: executedTools };
    }
    return { content: fullContent };
  }
  private async handleNonStreamResponse(
    completion: OpenAI.Chat.Completions.ChatCompletion,
    message: string,
    conversationHistory: Message[],
    documents: InsuranceDocument[]
  ) {
    const responseMessage = completion.choices[0]?.message;
    if (!responseMessage) {
      return { content: 'I apologize, but I encountered an issue processing your request.' };
    }
    if (!responseMessage.tool_calls) {
      return { content: responseMessage.content || 'I apologize, but I encountered an issue.' };
    }
    const toolCalls = await this.executeToolCalls(responseMessage.tool_calls as ChatCompletionMessageFunctionToolCall[]);
    const finalResponse = await this.generateToolResponse(message, conversationHistory, documents, responseMessage.tool_calls, toolCalls);
    return { content: finalResponse, toolCalls };
  }
  private async executeToolCalls(openAiToolCalls: ChatCompletionMessageFunctionToolCall[]): Promise<ToolCall[]> {
    return Promise.all(
      openAiToolCalls.map(async (tc) => {
        try {
          const args = tc.function.arguments ? JSON.parse(tc.function.arguments) : {};
          const result = await executeTool(tc.function.name, args);
          return { id: tc.id, name: tc.function.name, arguments: args, result };
        } catch (error) {
          return { id: tc.id, name: tc.function.name, arguments: {}, result: { error: String(error) } };
        }
      })
    );
  }
  private async generateToolResponse(
    userMessage: string,
    history: Message[],
    documents: InsuranceDocument[],
    openAiToolCalls: OpenAI.Chat.Completions.ChatCompletionMessageToolCall[],
    toolResults: ToolCall[]
  ): Promise<string> {
    const followUpCompletion = await this.client.chat.completions.create({
      model: this.model,
      messages: [
        { role: 'system', content: 'You are the Legacy Health Navigator. Respond naturally and strategically to the data discovered.' },
        ...history.slice(-3).map(m => ({ role: m.role, content: m.content })),
        { role: 'user', content: userMessage },
        { role: 'assistant', content: null, tool_calls: openAiToolCalls },
        ...toolResults.map((result, index) => ({
          role: 'tool' as const,
          content: JSON.stringify(result.result),
          tool_call_id: openAiToolCalls[index]?.id || result.id
        }))
      ],
      max_tokens: 16000
    });
    return followUpCompletion.choices[0]?.message?.content || 'Strategic step compiled.';
  }
  private buildConversationMessages(userMessage: string, history: Message[], documents: InsuranceDocument[]) {
    const docContext = documents.length > 0 
      ? `## REFERENCE CONTEXT (Data Primacy Documents)\n${documents.map(d => `[DOCUMENT: ${d.title} (${d.type})]\n${d.content}\n---`).join('\n')}`
      : 'No specific policy documents have been uploaded yet. Encourage the user to provide EOC/SBC for precise forensics.';
    const systemPrompt = `
      # MASTER PERSONA: Senior Health Insurance Auditor and Medical Billing Advocate
      You are an elite AI agent specialized in Forensic Analysis of Summary of Benefits (SBC), Evidence of Coverage (EOC), and Explanation of Benefits (EOB). Your mission is to protect the patient's finances.
      ## CORE OPERATING PRINCIPLES
      - **Data Primacy**: Prioritize uploaded policy documents over general knowledge. If a conflict exists, quote the specific page/section from the user's PDF/Document.
      - **Financial Precision**: Calculate patient responsibility using mathematical logic. Provide the "why" behind every number.
      - **Non-Evaluative Stance**: Provide mathematical and contractual facts. Do not label plans as "good" or "bad." 
      ## OPERATIONAL MODULES
      - **Audit Mode**: When an EOB or bill is provided, cross-reference CPT/HCPCS codes against the planâ€™s coverage for that "Place of Service". Check for "Balance Billing" or "Unbundling".
      - **Appeal Generation**: If a claim is denied, identify the specific "Denial Code." Draft a formal appeal letter citing "Medical Necessity" definitions found in the uploaded EOC.
      - **Alternative Care Analysis**: For drugs/procedures, search documents for "Step Therapy" or "Prior Authorization" protocols.
      ## INTERACTION STYLE
      - **Format**: Use JetBrains Mono for financial figures, CPT codes, and specific calculations.
      - **Actionable Outputs**: Every response must include a "Next Strategic Step" (e.g., call script or appeal bullet points).
      - **Tone**: Medical Grade Fintech - precise, authoritative, calm.
      ${docContext}
      ## LIMITATIONS
      - You do not provide legal or clinical medical advice. You are a financial advocate.
    `.trim();
    return [
      { role: 'system' as const, content: systemPrompt },
      ...history.slice(-10).map(m => ({
        role: m.role,
        content: m.content
      })),
      { role: 'user' as const, content: userMessage }
    ];
  }
  updateModel(newModel: string): void {
    this.model = newModel;
  }
}